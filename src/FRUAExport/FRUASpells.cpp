/******************************************************************************
* Filename: FRUASpells.cpp
* Copyright (c) 2013, UAF Development Team (email CocoaSpud@hotmail.com)
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
******************************************************************************/
#include "stdafx.h"
#include <string>

#include "globals.h"
#include "FRUASpells.h"
#include "FRUAStructs.h"
#include "Utilities.h"
#include "FRUAStringTables.h"

void FormatSpellJson(SImportFRUASpell spell, Json::Value &currSpell)
{
   /*
   BYTE type; // 0=cl,1=dr,2=mu,3=dev,4=dev
   BYTE foo1;
   BYTE castLevel; // if type=3->level=0, type=4->level=6
   BYTE range; // in squares, 255=touch
   BYTE rangePerLevel; // 12=DimensionDoor, 16=MinorGlobeOfInvulnerability
   BYTE duration; // in rounds
   BYTE durationPerLevel;
   BYTE targetingQty;
   BYTE targetingFlags;
   BYTE foo2;
   BYTE saveResult;
   BYTE foo3;
   BYTE saveVs;
   BYTE foo4;
   BYTE specialAbility;
   BYTE castInCampCombat; // 0=camp,1=combat,2=both
   BYTE foo5;
   BYTE castTime; // in segments
   BYTE priority;
   BYTE friendlyFire; // 0=allies only, 1=foes only
   BYTE foo6;
   BYTE foo7;

   Each spell is defined by a record of 22 bytes in length,
   with the data in each record allocated as follows:

   Offset	Definition

   0	Spell Class: 
      0 = Cleric
      1 = Druid
      2 = Mage
      3 = Device  (Examples: 57/Potion of Speed, 59/Potion of Giant Strength, 60/Javelin of Lightning, 61/Wand of Paralyzation, 62/Potion of Healing, 63/Elixir of Youth, 64/Necklace of Missiles)
      4 = Device  (Examples: 65/Wand of Magic Missiles, 95/Scroll of Prot. Dragons, 97/Potion of Invisibility, 99/Potion of Extra Healing)

   1	Set to zero.

   2	Spell level.  Spell level for devices is based on spell class as follows:
         Class 3 is spell level 0.
         Class 4 is spell level 6.

   3	Base range of spell in squares. 255 = Touch spell.

   4	Variable range of spell (in units of 1 square per level).
         Special cases:
         12 = Dimension Door
         16 = Minor Globe of Invulnerability
         Note that the ranges of those spells whose
         ranges are given in units of 0.25 or 0.5
         squares per level in the manual are actually
         too high.

   5	Base duration of spell in rounds.

   6	Variable duration of spell in rounds per level.

   7  The known field values can be defined as follows:
         0 = No target in combat (either spell affects caster, or spell is camp only)
         1 = 1-2 targets in combat
         2 = 1-3 targets in combat
         3 = 1-4 targets in combat
         4 = Single target in combat
         5 = 1-5 targets in combat:  Faerie Fire and Charm Monsters. There may be a factor involving range from first target.
         6 = 1-3 targets in combat: Hold Person (Cleric spell)
         7 = 1-4 targets in combat: All other Hold spells
         8 = Line/Cone Area Effect:     Lightning Bolt, Dimension Door, Fear, Cone of Cold, and Meteor Swarm. The result is a single target for spells not originally designed for this option.
         9 = Small Area Effect:  Sleep, Stinking Cloud, Dispel Magic, Invisibility 10' Radius, Cloudkill, Blade Barrier, Death Spell, Mass Charm, Power Word Kill
         10 = Medium Area Effect:  Bless, Curse, Haste, Slow, Ice Storm, Mass Invisibility, Power Word Blind
         11 = Large Area Effect: Fireball, Haste, Confusion, Delayed Blast Fireball
         31 = Special (Silence 15' Radius)
         240 = Special (Snake Charm / Barkskin)

   8	Spell class:
      0 = Combat only spell
      1 = Spell affects self only
      2 = Spell affects selected individual(s)
      3 = Spell affects entire party

   9	Set to zero.

   10	Save Allowed. 
      0 = No Save Allowed
      1 = Save to Negate Spell
      2 = Save for Half Damage
      3 = Special Save

   11	Set to zero.

   12	Poison Effect or Save Type:
      0 = Poison Immunity protects (save vs. poison)
      4 = Non-Poison spell (save vs. spell)
      Note:  Values of 1-3 may correspond to other save types, but this has not yet been confirmed.

   13	Set to zero.

   14	Special effect/ability code generated by spell.

   15	Camp/Combat Casting.
      0 = Camp only spell
      1 = Combat only spell
      2 = Camp and Combat spell

   16	Set to zero.

   17	Casting time in segments.

   18	Priority:  In "Quick" mode, the computer searches through the caster's memorized spells
      and will (if possible) cast the spell with the highest priority.

   19	Attack Spell Flag.
      0 = Spell Cast on Allies
      1 = Spell Cast on Foes

   20	Set to zero.

   21	Some examples for study:
   1 = Examples (	21/Sleep, 25/C: Silence 15 Radius, 34/Stinking Cloud, 41/C: Dispel Magic, 46/Dispel Magic, 59 (Potion of Giant Strength))
   3 = Examples (	47/Fireball)
   0 = All the other spells

   22 Set to zero.
   */

   currSpell["name"] = spell.spellName;

   switch (spell.spellData.type)
   {
   case 0: 
      currSpell["spell_book"] = "cleric"; 
      currSpell["spell_level"] = IntToString(spell.spellData.castLevel);
      break;

   case 1: 
      currSpell["spell_book"] = "druid"; 
      currSpell["spell_level"] = IntToString(spell.spellData.castLevel);
      break;

   case 2: 
      currSpell["spell_book"] = "magic-user"; 
      currSpell["spell_level"] = IntToString(spell.spellData.castLevel);
      break;

   case 3: 
      currSpell["spell_book"] = "device"; 
      currSpell["spell_level"] = IntToString(0);
      break;

   case 4: 
      currSpell["spell_book"] = "device"; 
      currSpell["spell_level"] = IntToString(6);
      break;

   default: currSpell["spell_book"] = UnknownString; break;
   }

   if (spell.spellData.range == 255)
      currSpell["range_base_squares"] = "touch";
   else
      currSpell["range_base_squares"] = IntToString(spell.spellData.range);

   currSpell["range_squares_added_per_level"] = IntToString(spell.spellData.rangePerLevel);
   currSpell["duration_base_rounds"] = IntToString(spell.spellData.duration);
   currSpell["duration_rounds_added_per_level"] = IntToString(spell.spellData.durationPerLevel);

   /*
   7  The known field values can be defined as follows:
      0 = No target in combat (either spell affects caster, or spell is camp only)
      1 = 1-2 targets in combat
      2 = 1-3 targets in combat
      3 = 1-4 targets in combat
      4 = Single target in combat
      5 = 1-5 targets in combat: Faerie Fire and Charm Monsters. There may be a factor involving range from first target.
      6 = 1-3 targets in combat: Hold Person (Cleric spell)
      7 = 1-4 targets in combat: All other Hold spells
      8 = Line/Cone Area Effect:  Lightning Bolt, Dimension Door, Fear, Cone of Cold, and Meteor Swarm. The result is a single target for spells not originally designed for this option.
      9 = Small Area Effect: Sleep, Stinking Cloud, Dispel Magic, Invisibility 10' Radius, Cloudkill, Blade Barrier, Death Spell, Mass Charm, Power Word Kill
      10 = Medium Area Effect: Bless, Curse, Haste, Slow, Ice Storm, Mass Invisibility,Power Word Blind
      11 = Large Area Effect: Fireball, Haste, Confusion, Delayed Blast Fireball
      31 = Special (Silence 15' Radius)
      240 = Special (Snake Charm / Barkskin)
   */

   CString strSpellName = spell.spellName;

   switch (spell.spellData.targetingQty)
   {
   case 0: 
      currSpell["target_type"] = "self";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "0";
      break;
   case 1: 
      currSpell["target_type"] = "select_by_target_count";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "2";
      currSpell["target_area_square_size"] = "0";
      break;
   case 2: 
      currSpell["target_type"] = "select_by_target_count";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "3";
      currSpell["target_area_square_size"] = "0";
      break;
   case 3: 
      currSpell["target_type"] = "select_by_target_count";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "4";
      currSpell["target_area_square_size"] = "0";
      break;
   case 4: 
      currSpell["target_type"] = "select_by_target_count";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "0";
      break;
   case 5: 
      currSpell["target_type"] = "select_by_target_count";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "0";
      break;
   case 6: 
      currSpell["target_type"] = "select_by_target_count";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "3";
      currSpell["target_area_square_size"] = "0";
      break;
   case 7: 
      currSpell["target_type"] = "select_by_target_count";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "0";
      break;
   case 8: 
      //8 = Line/Cone Area Effect:  Lightning Bolt, Dimension Door, Fear, Cone of Cold, and Meteor Swarm. 
      //                            The result is a single target for spells not originally designed for this option.
      //AreaCircle, SelectByHitDice, AreaLinePickStart, AreaLinePickEnd, AreaSquare, AreaCone
      if (strSpellName.Find("Cone") == -1)
      {
         // this is probably not correct for all spells that use a 'line' and we 
         // could set based on spell name
         currSpell["target_type"] = "select_area_line_end";
      }
      else
      {
         currSpell["target_type"] = "select_area_cone";
      }
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "0";
      break;
   case 9: 
      //9 = Small Area Effect: Sleep, Stinking Cloud, Dispel Magic, Invisibility 10' Radius, 
      //                       Cloudkill, Blade Barrier, Death Spell, Mass Charm, Power Word Kill
      ////AreaCircle, SelectByHitDice, AreaLinePickStart, AreaLinePickEnd, AreaSquare, AreaCone
      if (strSpellName.Find("Radius") == -1)
      {
         // this is probably not correct for all spells that use a square/circle and we 
         // could set based on spell name
         currSpell["target_type"] = "select_area_square";                  
      }
      else
      {
         currSpell["target_type"] = "select_area_circle";
      }      
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "2";
      break;
   case 10: 
      currSpell["target_type"] = "select_area_square";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "3";
      break;
   case 11: 
      currSpell["target_type"] = "select_area_square";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "4";
      break;
   case 31: 
      currSpell["target_type"] = "select_area_circle";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "2";
      break;
   case 240: 
      currSpell["target_type"] = "none";
      currSpell["target_min_count"] = "1";
      currSpell["target_max_count"] = "1";
      currSpell["target_area_square_size"] = "0";
      break;
   default:
      currSpell["target_type"] = UnknownString;
      currSpell["target_min_count"] = UnknownString;
      currSpell["target_max_count"] = UnknownString;
      currSpell["target_area_square_size"] = UnknownString;
      break;
   }

   //8	Spell class:
   //   0 = Combat only spell
   //   1 = Spell affects self only
   //   2 = Spell affects selected individual(s)
   //   3 = Spell affects entire party
   if (spell.spellData.spellClass == 0)
      currSpell["combat_only"] = "1";
   else
      currSpell["combat_only"] = "0";

   switch (spell.spellData.spellClass)
   {
   case 0: currSpell["non_combat_targeting"] = "none";  break;
   case 1: currSpell["non_combat_targeting"] = "self";  break;
   case 2: currSpell["non_combat_targeting"] = "selected_party_members";  break;
   case 3: currSpell["non_combat_targeting"] = "entire_party";  break;
   default: currSpell["non_combat_targeting"] = UnknownString; break;
   }

   //10	Save Allowed. 
   //   0 = No Save Allowed
   //   1 = Save to Negate Spell
   //   2 = Save for Half Damage
   //   3 = Special Save
   switch (spell.spellData.saveResult)
   {
   case 0: currSpell["save_result"] = "no_save_possible"; break;
   case 1: currSpell["save_result"] = "save_negates"; break;
   case 2: currSpell["save_result"] = "save_for_half_dmg"; break;
   case 3: currSpell["save_result"] = "special_save"; break;
   default: currSpell["save_result"] = UnknownString; break;
   }

   //12	Poison Effect or Save Type:
   //   0 = Poison Immunity protects (save vs. poison)
   //   4 = Non-Poison spell (save vs. spell)
   //   Note:  Values of 1-3 may correspond to other save types, but this has not yet been confirmed.
   if (spell.spellData.saveResult == 0)
   {
      currSpell["save_vs"] = "none";
   }
   else
   {
      switch (spell.spellData.saveVs)
      {
      case 0: currSpell["save_vs"] = "save_vs_poison"; break;
      case 4: currSpell["save_vs"] = "save_vs_spell"; break;
      default: currSpell["save_vs"] = UnknownString; break;
      }
   }

   //14	Special effect/ability code generated by spell.
   currSpell["special_ability"] = FRUAGetSpecAbText(spell.spellData.specialAbility);

   //15	Camp/Combat Casting.
   //   0 = Camp only spell
   //   1 = Combat only spell
   //   2 = Camp and Combat spell
   switch (spell.spellData.castInCampCombat)
   {
   case 0: 
      currSpell["cast_in_camp"]   = "1";
      currSpell["cast_in_combat"] = "0";
      break;
   case 1: 
      currSpell["cast_in_camp"]   = "0";
      currSpell["cast_in_combat"] = "1";
      break;
   case 2: 
      currSpell["cast_in_camp"]   = "1";
      currSpell["cast_in_combat"] = "1";
      break;
   default: 
      currSpell["cast_in_camp"]   = UnknownString;
      currSpell["cast_in_combat"] = UnknownString;
      break;
   }   

   //17	Casting time in segments.
   currSpell["cast_time_in_segments"] = IntToString(spell.spellData.castTime);
   //18	Priority:
   currSpell["cast_priority"] = IntToString(spell.spellData.priority);
   //19	Attack Spell Flag
   if (spell.spellData.friendlyFire == 0)
      currSpell["target_friendly"] = "1";
   else
      currSpell["target_friendly"] = "1";

   currSpell["unsure_byte"] = IntToString(spell.spellData.unsure);

   Json::ValueIterator itCurr = currSpell.begin();
   while (itCurr != currSpell.end())
   {
      TRACE("SPELL: %s = %s\n", itCurr.key().asCString(), (*itCurr).asCString());
      ++itCurr;
   }
}

void PopulateSpellNames(const char *rootFolder)
{  
   /*
   for (int i=0;i<MAX_FRUA_SPELLS;i++)
   {
      CString strName = FRUAGetSpellText(i);
      strncpy(FRUASpells[i].spellName, strName, SImportFRUASpell::MAX_SPELL_NAME);
      FRUASpells[i].spellName[SImportFRUASpell::MAX_SPELL_NAME] = '\0';
   }
   */
 
   FILE *fp;
   CString fullPath;

   struct SSpellNamePtrRec
   {
      BYTE spellNameOffset1;
      BYTE spellNameOffset2;
      WORD spellNameAddress; // these bytes are present but not used in the ckit.exe file so we repurpose them to hold the byte-swapped offset
   };

   SSpellNamePtrRec spellNamePointers[MAX_FRUA_SPELLS];
   memset(spellNamePointers, 0, sizeof(spellNamePointers));

   try
   {
      fullPath = rootFolder;
      fullPath += "\\ckit.exe";

      fp = fopen(fullPath, "rb");
      if (fp == NULL)
      {
         //AbortOnError("failed to open items.dat");
         printf("NOT IMPORTING SPELL NAMES - MISSING CKIT.EXE\n");
         return;
      }

      // move file pointer to spell names offset
      fseek(fp, SPELL_NAMES_BYTE_OFFSET, SEEK_SET);

      int spellCount=0;
      BOOL success = TRUE;
      while ((spellCount < MAX_FRUA_SPELLS) && (success))
      {
         success = (fread(&spellNamePointers[spellCount], sizeof(SSpellNamePtrRec), 1, fp) == 1);
         if (success)
         {
            unsigned short temp;
            temp = (spellNamePointers[spellCount].spellNameOffset1 & 0xff);
            temp += ((spellNamePointers[spellCount].spellNameOffset2 & 0xff) << 8);

            spellNamePointers[spellCount].spellNameAddress = temp;
         }

         spellCount++;
      }
         

      for (int i=0; i<MAX_FRUA_SPELLS; i++)
      {
         fseek(fp, spellNamePointers[i].spellNameAddress+544864, SEEK_SET);

         bool nameFinished = false;
         char readByte;
         CString tempName = "";
         while ((nameFinished == false) && (success))
         {
            success = (fread(&readByte, 1, 1, fp) == 1);
            if (success)
            {
               if (readByte == 0)
                  nameFinished = true;
               else
                  tempName += readByte;
            }
         }

         if (nameFinished)
         {
            CString strDebug;
            strDebug.Format("Spell Name %03u : \'%s\'\n", i, tempName);
            OutputDebugString(strDebug);

            if (tempName.GetLength() > 0)
               strncpy(FRUASpells[i].spellName, tempName, SImportFRUASpell::MAX_SPELL_NAME);
         }
      }
      fclose(fp);
   }
   catch (...)
   {
      printf("Spell names not exported - failed to open ckit.exe\n");
   }
}

bool ReadFRUASpellFile(const char *rootFolder)
{
   FILE *fp;
   CString fullPath;
   int spellCount;

   try
   {
      fullPath = rootFolder;
      fullPath += "\\ckit.exe";

      fp = fopen(fullPath, "rb");
      if (fp == NULL)
      {
         return false;
      }
      else
      {
         // move file pointer to spell data offset
         fseek(fp, SPELL_TABLE_BYTE_OFFSET, SEEK_SET);

         spellCount=0;
         BOOL success = TRUE;
         while ( (spellCount < MAX_FRUA_SPELLS) && (success) )
         {
            success = (fread(&FRUASpells[spellCount].spellData, sizeof(FRUASpells[spellCount].spellData), 1, fp) == 1);
            if (success)
               spellCount++;
         }
         fclose(fp);
      }

      return true;
   }
   catch(...)
   {
      return false;
   }
}

void ReadSpells(Json::Value &root)
{
   printf("Exporting spells\n");   

   // The spell info that we are reading here resides in the ckit.exe file.
   // I dont forsee a situation where ckit.exe will be present in the FRUA
   // design folder, but if FRUAExport.exe is installed in the FRUA folder
   // then of course it will be found in the local folder.
   //
   // if ckit.exe is found, then all spell info records will be read.
   // if not found, then we will read the defaults file and use that info instead.

   // RBT: trying current folder, but also one folder up
   //      because that is typical location for FRUA files
   //      
   //     C:\UA
   //     C:\UA\Wonderful.dsn   

  
   // this file might exist, and will over ride the defaults
   bool fruaFileFound = false;
   if (strlen(FRUAFolder) > 0)
   {
      fruaFileFound = ReadFRUASpellFile(FRUAFolder); // user folder
      if (fruaFileFound)
      {
         // spell definitions and spell names are in two different places
         PopulateSpellNames(FRUAFolder);
      }
   }

   // if file not read from user design folder, try the local folder
   if (!fruaFileFound)
   {
      if (ReadFRUASpellFile(".")) // local folder
      {
         // spell definitions and spell names are in two different places
         PopulateSpellNames(".");         
      }
      else
      {
         printf("Did not find ckit.exe, using spell defaults\n");
      }
   }

   if (!fruaFileFound)
   {
      // this file should always exist
      ReadSpellDefaultsFile();
   }

   int spellCount = 0;
   Json::Value spelllArray(Json::arrayValue);

   CString strIdKey;

   for (int i=0; i<MAX_FRUA_SPELLS; i++)
   {      
      Json::Value spell;
      spell["id"] = IntToString(i+1);

      TRACE("SPELL %u BEGIN\n", i+1);

      // format item data as json
      FormatSpellJson(FRUASpells[i], spell);

      TRACE("SPELL %u END\n", i+1);

      spelllArray.append(spell);
      spellCount++;
   }

   root["spells"] = spelllArray;
   root["spells_count"] = IntToString(spellCount);   
}

void WriteSpellDefaultsFile()
{
   printf("Write spells defaults file\n");

   FILE *pFile = fopen("default_spells.dat", "w+b");
   if (pFile != NULL)
   {
      fwrite( &FRUASpells, sizeof(FRUASpells), 1, pFile);
      fclose(pFile);
   }
}

void ReadSpellDefaultsFile()
{
   FILE *pFile = fopen("default_spells.dat", "rb");
   if (pFile != NULL)
   {
      int rc = fread( FRUASpells, sizeof(FRUASpells), 1, pFile);
      fclose(pFile);
   }
   else
   {
      printf("failed to open spell defaults file\n");
   }
}
