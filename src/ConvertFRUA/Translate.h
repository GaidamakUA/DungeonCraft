#define JKEY_PASSWORD               "password"
#define JKEY_NUMBEROFTRIES          "numberOfTries"
#define JKEY_NUMATTEMPTSALLOWED     "num_attempts_allowed"
#define JKEY_SUCCESSCHAIN           "successChain"
#define JKEY_SUCCESSEVENT           "success_event"
#define JKEY_FAILCHAIN              "failChain"
#define JKEY_FAILEVENT              "fail_event"
#define JKEY_SUCCESSACTION          "successAction"
#define JKEY_success_action         "success_action"
#define JKEY_FAILACTION             "failAction"
#define JKEY_fail_action            "fail_action"
#define JKEY_MATCHCASE              "matchCase"
#define JKEY_SUCCESSDESTINATION     "successDestination"
#define JKEY_FAILDESTINATION        "failDestination"
#define JKEY_EXECUTEEVENTATDEST     "executeEventAtDestination"
#define JKEY_ENTRYPOINT             "entryPoint"
#define JKEY_LEVEL                  "level"
#define JKEY_XY                     "xy"
#define JKEY_FACING                 "facing"
#define JKEY_DISTANCE               "distance"
#define JKEY_CHARACTERID            "characterID"
#define JKEY_CHARACTER              "character"
#define JKEY_HITPOINTMOD            "HitPointModification"
#define JKEY_USEORIGINAL            "UseOriginal"
#define JKEY_EVENTID                "eventID"
#define JKEY_PICTURE1               "picture1"
#define JKEY_PICTURE2               "picture2"
#define JKEY_TEXT                   "text"
#define JKEY_TEXT2                  "text2"
#define JKEY_TEXT3                  "text3"
#define JKEY_CHAINEVENTHAPPEN       "chainEventHappen"
#define JKEY_CHAINEVENTNOTHAPPEN    "chainEventNotHappen"
#define JKEY_TIMER                  "timer"
#define JKEY_PARTICULAR             "particular"
#define JKEY_PICTYPE                "picType"
#define JKEY_FILENAME               "filename"
#define JKEY_TIMEDELAY              "timeDelay"
#define JKEY_NUMFRAME               "numFrame"
#define JKEY_WIDTH                  "width"
#define JKEY_HEIGHT                 "height"
#define JKEY_FLAGS                  "flags"
#define JKEY_MAXLOOPS               "maxLoops"
#define JKEY_STYLE                  "style"
#define JKEY_ALLOWCENTERING         "allowCentering"
#define JKEY_USEALPHA               "useAlpha"
#define JKEY_ALPHA                  "alpha"
#define JKEY_CONTROL                "control"
#define JKEY_ONCEONLY               "onceOnly"
#define JKEY_CHAINTRIGGER           "chainTrigger"
#define JKEY_EVENTTRIGGER           "eventTrigger"
#define JKEY_RACE                   "race"
#define JKEY_CLASS                  "class"
#define JKEY_BASECLASS              "baseclass"
#define JKEY_ITEM                   "item"
#define JKEY_SPELL                  "spell"
#define JKEY_SPELLCLASS             "spellClass"
#define JKEY_SPELLLEVEL             "spellLevel"
#define JKEY_GPDLBINARY             "gpdlBinary"
#define JKEY_GPDLDATA               "gpdlData"
#define JKEY_GENDER                 "gender"
#define JKEY_QUEST                  "quest"
#define JKEY_CHANCE                 "chance"
#define JKEY_SPECIALITEM            "specialItem"
#define JKEY_SPECIALKEY             "specialKey"
#define JKEY_PARTYXY                "partyXY"
#define JKEY_FORCEEXIT              "forceExit"
#define JKEY_FORCEBACKUPONESTEP     "force_backup_one_step"
#define JKEY_CHAIN                  "chain"
#define JKEY_DEATHSOUND             "deathSound"
#define JKEY_MOVESOUND              "moveSound"
#define JKEY_TURNUNDEADSOUND        "turnUdeadSound"
#define JKEY_DIRECTION              "direction"
#define JKEY_SURPRISE               "surprise"
#define JKEY_AUTOAPPROACH           "autoApproach"
#define JKEY_OUTDOORS               "outdoors"
#define JKEY_MONSTERTREASURE        "monsterTreasure"
#define JKEY_PARTYNEVERDIES         "partyNeverDies"
#define JKEY_NOMAGIC                "noMagic"
#define JKEY_MONSTERMORALE          "monsterMorale"
#define JKEY_TURNMODIFIER           "turnModifier"
#define JKEY_RANDOMMONSTER          "randomMonster"
#define JKEY_PARTYGAINSEXP          "partyGainsExp"
#define JKEY_MONSTERS               "monsters"
#define JKEY_SOUNDS                 "sounds"
#define JKEY_BACKGROUNDSOUNDS       "backgroundSounds"
#define JKEY_NIGHTSOUNDS            "nightSounds"
#define JKEY_USENIGHTMUSIC          "useNightMusic"
#define JKEY_STARTTIME              "startTime"
#define JKEY_ENDTIME                "endTime"
#define JKEY_GENERAL                "general"
#define JKEY_EVENTTYPE              "eventType"
#define JKEY_EXPERIENCE             "experience"
#define JKEY_SOUND                  "sound"
#define JKEY_WHO                    "who"
#define JKEY_SILENTGIVETOACTIVECHAR "silentGiveToActiveChar"
#define JKEY_MONEY                  "money"
#define JKEY_COINS                  "coins"
#define JKEY_GEMS                   "gems"
#define JKEY_JEWELS                 "jewels"
#define JKEY_USESTARTLOCATION       "useStartLocation"
#define JKEY_EXECUTEEVENT           "executeEvent"
#define JKEY_STEPS                  "steps"
#define JKEY_STEPNUM                "stepNum"
#define JKEY_STEP                   "step"
#define JKEY_HEALHP                 "healHP"
#define JKEY_HEALDRAIN              "healDrain"
#define JKEY_HEALCURSE              "healCurse"
#define JKEY_AFFECTS                "affects"
#define JKEY_ADJUSTMENT             "adjustment"
#define JKEY_HP                     "HP"
#define JKEY_ADJUSTHP               "adjustHP"
#define JKEY_JOURNALENTRY           "journalEntry"
#define JKEY_NUMBEROFMONSTERS       "number"
#define JKEY_TYPE                   "type"
#define JKEY_MONSTERNAME            "name"
#define JKEY_FRIENDLY               "friendly"
#define JKEY_MORALEADJUST           "moraleAdjustment"
#define JKEY_DICESIDES              "diceSides"
#define JKEY_NUMBEROFDICE           "diceNumber"
#define JKEY_DICEBONUS              "diceBonus"
#define JKEY_USENUMBER              "fixedNumberOfMonsters"
#define JKEY_POSSESSIONS            "possessions"
#define JKEY_MUSTHITRETURN          "mustHitReturn"
#define JKEY_HIGHLIGHT              "highlight"
#define JKEY_DAYS                   "days"
#define JKEY_HOURS                  "hours"
#define JKEY_MINUTES                "minutes"
#define JKEY_ALLOWSTOP              "allowStop"
#define JKEY_SETTIME                "setTime"
#define JKEY_PASSSILENT             "passSilent"
#define JKEY_BUTTONLIST             "buttonList"
#define JKEY_TITLE                  "title"
#define JKEY_PARTICULAR             "particular"
#define JKEY_OPTIONS                "options"
#define JKEY_NUMBUTTON              "numButton"
#define JKEY_YESCHAINACTION         "yesChainAction"
#define JKEY_NOCHAINACTION          "noChainAction"
#define JKEY_YESCHAIN               "yesChain"
#define JKEY_NOCHAIN                "noChain"
#define JKEY_POSSIBLECHAIN          "possibleChain"
#define JKEY_EVERYMIN               "everyMin"
#define JKEY_PREVMINCHECKED         "prevMinChecked"
#define JKEY_RESTEVENT              "restEvent"
#define JKEY_ALLOWRESTING           "allowResting"
#define JKEY_FORCEEXIT              "forceExit"
#define JKEY_COSTFACTOR             "costFactor"
#define JKEY_COSTTOID               "costToID"
#define JKEY_BUYBACKPERCENTAGE      "buybackPercentage"
#define JKEY_BUYITEMSOLDONLY        "buyItemsSoldOnly"
#define JKEY_SELLPRICE              "sellPrice"
#define JKEY_CANID                  "canID"
#define JKEY_CANAPPRAISEGEMS        "canAppraiseGems"
#define JKEY_CANAPPRAISEJEWELS      "canAppraiseJewels"
#define JKEY_INVENTORY              "inventory"
#define JKEY_TEMPLE                 "temple"
#define JKEY_SHOP                   "shop"
#define JKEY_INN                    "inn"
#define JKEY_TRAIN                  "train"
#define JKEY_TAVERN                 "tavern"
#define JKEY_VAULT                  "vault"
#define JKEY_CHAINS                 "chains"
#define JKEY_STOREITEMS             "putItemsInVault"
#define JKEY_WHICHVAULT             "whichVault"
#define JKEY_MONEYNUMBER            "money"
#define JKEY_MONEYTYPE              "moneyType"
#define JKEY_TAKEITEMS              "takeWhat"
#define JKEY_JEWELRY                "jewelry"
#define JKEY_ITEMS                  "items"
#define JKEY_TAKEEFFECTS            "takeFrom"
#define JKEY_ITEMSQUANTITY          "itemsQuantity"
#define JKEY_MONEYQUANTITY          "moneyQuantity"
#define JKEY_GEMSQUANTITY           "gemsQuantity"
#define JKEY_JEWELRYQUANTITY        "jewelryQuantity"
#define JKEY_ITEMLIST               "itemList"
#define JKEY_PLATINUM               "platinum"
#define JKEY_SUCCESSAMOUNT          "success_amount"
#define JKEY_INFLATION              "inflation"
#define JKEY_BARKEEP                "barkeep"
#define JKEY_ALLOWFIGHTS            "allowFights"
#define JKEY_FIGHTCHAIN             "fightChain"
#define JKEY_ALLOWDRINKS            "allowDrinks"
#define JKEY_DRINKCHAIN             "drinkChain"
#define JKEY_DRINKPOINTTRIGGER      "drinkPointTrigger"
#define JKEY_TALEORDER              "taleOrder"
#define JKEY_EACHTALEONCEONLY        "eachTaleOnlyOnce"
#define JKEY_DRINKS                 "drinks"
#define JKEY_TALES                  "tales"
#define JKEY_DRINKS                 "drinks"
#define JKEY_INDEX                  "index"
#define JKEY_POINTS                 "points"
#define JKEY_NAME                   "name"
#define JKEY_COUNT                  "count"
#define JKEY_ASKYESNO               "askYesNo"
#define JKEY_TRANSFER               "transfer"
#define JKEY_DESTROYDROW            "destroyDrow"
#define JKEY_ACTIVATEBEFOREENTRY    "activateBeforeEntry"
#define JKEY_TRANSFERLOCATION       "transferLocation"
#define JKEY_ALLOWDONATIONS         "allowDonations"
#define JKEY_COSTFACTOR             "costFactor"
#define JKEY_DONATIONTRIGGER        "donationTrigger"
#define JKEY_DONATIONCHAIN          "donationChain"
#define JKEY_TOTALDONATION          "totalDonation"
#define JKEY_MAXLEVEL               "maxLevel"
#define JKEY_SPELLBOOK              "spellbook"
#define JKEY_WAITFORRETURN          "waitForReturn"
#define JKEY_FORCEBACKUP            "forceBackup"
#define JKEY_HIGHLIGHTTEXT          "highLightText"
#define JKEY_MINLEVEL               "minLevel"
#define JKEY_MAXLEVEL               "maxLevel"
#define JKEY_WHATEVER               "whatever"
#define JKEY_ID                     "id"
#define JKEY_BASECLASSES            "baseclasses"
#define JKEY_COST                   "cost"
#define JKEY_ENDPLAY                "endPlay"
#define JKEY_ITEMCHECK              "itemCheck"
#define JKEY_MATHITEMTYPE           "mathItemType"
#define JKEY_RESULTITEMTYPE         "resultItemType"
#define JKEY_MATHAMOUNT             "mathAmount"
#define JKEY_MATHITEMINDEX          "mathItemIndex"
#define JKEY_RESULTITEMINDEX        "resultItemIndex"
#define JKEY_OPERATION              "operation"
#define JKEY_VAULTID                "vaultID"
#define JKEY_POSSIBLE               "possible"
#define JKEY_SUCCESSTELEPORT        "successTeleport"
#define JKEY_FAILTELEPORT           "failTeleport"
#define JKEY_ALWAYSSUCCEEDS         "alwaysSucceeds"
#define JKEY_ALWAYSFAILS            "alwaysFails"
#define JKEY_CHECKSTR               "checkStr"
#define JKEY_CHECKINT               "checkInt"
#define JKEY_CHECKWIS               "checkWis"
#define JKEY_CHECKDEX               "checkDex"
#define JKEY_CHECKCON               "cedckCon"
#define JKEY_CHECKCHA               "checkCha"
#define JKEY_CHECKPP                "checkPP"
#define JKEY_CHECKOL                "checkOL"
#define JKEY_CHECKFT                "checkFT"
#define JKEY_CHECKMS                "checkMS"
#define JKEY_CHECKHS                "checkHS"
#define JKEY_CHECKHN                "checkHN"
#define JKEY_CHECKCW                "checkCW"
#define JKEY_CHECKRL                "checkRL"
#define JKEY_STRBONUS               "strBonus"
#define JKEY_COMPARETODIE           "compareToDie"
#define JKEY_DIESIDES               "dieSides"
#define JKEY_SUCCESSTRANSFER        "successTransfer"
#define JKEY_FAILTRANSFER           "failTransfer"
#define JKEY_VALUE                  "value"
#define JKEY_ITEMID                 "itemID"
#define JKEY_READY                  "ready"
#define JKEY_QUANTITY               "quantity"
#define JKEY_IDENTIFIED             "identified"
#define JKEY_CHARGES                "charges"
#define JKEY_CURSED                 "cursed"
#define JKEY_PAID                   "paid"
#define JKEY_KEY                    "key"
#define JKEY_PRESENT                "present"
#define JKEY_LABEL                  "label"
#define JKEY_POSTCHAINACTION        "postChainAction"
#define JKEY_SPELLLIST              "spellList"
#define JKEY_USELIMITS              "useLimits"
#define JKEY_ITEMTYPE               "itemtype"
#define JKEY_ITEMINDEX              "itemIndex"
#define JKEY_MEMORIZED              "memorized"
#define JKEY_SELECTED               "selected"
#define JKEY_MONSTERSPEED           "monsterSpeed"
#define JKEY_ZERORANGERESULT        "zeroRangeResult"
#define JKEY_COMBATCHAIN            "combatChain"
#define JKEY_TALKCHAIN              "talkChain"
#define JKEY_ESCAPECHAIN            "escapeChain"
#define JKEY_ENCOUNTERBUTTONS       "encounterButtons"
#define JKEY_NUMBEROFATTACKS        "numberOfAttacks"
#define JKEY_CHANCEPERATTACK        "chancePerAttack"
#define JKEY_DAMAGEDICE             "damageDice"
#define JKEY_SAVEBONUS              "saveBonus"
#define JKEY_ATTACKTHAC0            "attackTHAC0"
#define JKEY_EVENTSAVE              "eventSave"
#define JKEY_SPELLSAVE              "spellSave"
#define JKEY_ALLOWEDUPCLOSE         "allowedUpClose"
#define JKEY_OPTIONRESULT           "optionResult"
#define JKEY_ONLYUPCLOSE            "onlyUpClose"
#define JKEY_ACCEPTTYPE             "acceptType"
#define JKEY_FAILONREJECT           "failOnReject"
#define JKEY_QUESTNUM               "questNum"
#define JKEY_QUESTSTAGE             "questStage"
#define JKEY_ACCEPTCHAIN            "acceptChain"
#define JKEY_REJECTCHAIN            "rejectChain"
#define JKEY_COMPLETEONACCEPT       "completeOnAccept"




const char *MonsterType(int type);
int MonsterType(const CString& type);


#define CHAR_TYPE           ((BYTE)1)
#define NPC_TYPE            ((BYTE)2)
#define MONSTER_TYPE        ((BYTE)3)
#define FAKE_CHARACTER_TYPE ((BYTE)127)
#define IN_PARTY_TYPE       ((BYTE)128)

#define SPECIAL_OBJECT_NOTHING  0x00
#define SPECIAL_OBJECT_TAKE     0x01
#define SPECIAL_OBJECT_GIVE     0x02
#define SPECIAL_OBJECT_CHECK    0x04

const int ViewportX = 48;  // these can change in editor based on window position and size,
const int ViewportY = 57;  // but these are static in the game
const int ViewportWidth = 176;
const int ViewportHeight = 211;
const RECT ViewportBkgrnd = {0,0,176,211};
const int PartyNames_nx = 275; //DLD 12/20/00
const int PartyNames_ny = 18; // these allow changing the positions upon screen
const int PartyNames_wx = 18; // of Party Names, Map Location, Big Pic, and version text
const int PartyNames_wy = 18; //
const int LocationText_x = 275; //
const int LocationText_y = 280; //
const int BigPic_w = 612;      //
const int BigPic_h = 292;      //
const int BigPic_x = 14;      //
const int BigPic_y = 16;      //
const int VersionText_x = 280; //
const int VersionText_y = 301; //end add
enum { COMBAT_TILE_WIDTH=48, COMBAT_TILE_HEIGHT=48 };



class PIC_DATA 
{
public:
  PIC_DATA(void){Clear();};
  void Clear(void);
  void Export(JWriter& jw, const char *name);
  void Read(JReader& jr, const char *name);
  void ReadSmallPicFile(JReader& jr, const char *name);
  void SetDefaults(void)
  {
    ASSERT (picType != BogusDib);

    if (   (NumFrames > 0) 
        && (FrameWidth > 0) 
        && (FrameHeight > 0) 
        && (picType != BigPicDib) 
        && (picType != SmallPicDib) 
        && (picType != IconDib) 
        && (picType != SpriteDib)) //DLD 12/20/00
      return;
  
    switch (picType)
    {
    case SmallPicDib:
      sx = ViewportX;
      sy = ViewportY;
      FrameWidth = ViewportWidth;
      FrameHeight = ViewportHeight;
      NumFrames = 1;
      //SetPre0840LoopForeverDefaults();
      break;
    case IconDib:
      sx = -1; // never used by icons
      sy = -1;
      FrameWidth = COMBAT_TILE_WIDTH;
      FrameHeight = COMBAT_TILE_HEIGHT;
      NumFrames = 2; // 1 ready, 1 attack pose
      //SetPre0840NonLoopDefaults();
      break;
    case SpriteDib:
      sx = ViewportX;
      sy = ViewportY;
      FrameWidth = ViewportWidth;
      FrameHeight = ViewportHeight;
      NumFrames = 3; // 1 for each distance from party: UpClose, Near, Distant
      //SetPre0840NonLoopDefaults();
      break;
    case BigPicDib:
      sx = BigPic_x;         //DLD 12/20/00 //sx = ViewportScreenX;
      sy = BigPic_y;         // sy = ViewportScreenY;
      FrameWidth = BigPic_w; // FrameWidth = 608;
      FrameHeight = BigPic_h;//FrameHeight = 288; //end add change 
      NumFrames = 1;
      //SetPre0840NonLoopDefaults();
      break;

    default:
      ASSERT( FALSE );
      break;
    }
  };

  enum 
  { 
    AS_None=0,        // all frames are sequenced
    AS_Directional=1, // 1 frame per direction: N,E,S,W,NW,NE,SW,SE
    AS_Radius=2,      // single frame covers target area radius
    AS_EachTarget=3   // single frame covers each target character only
  };

  // flags that alter behavior of the animation
  enum
  {
    AF_None=0,
    AF_KeypressBeforeLoop=1,
    AF_MaxLoopCounter=2,
    AF_Loop=4,
    AF_LoopForever=8
  };

  SurfaceType picType;
  CString filename;
  int timeDelay;
  int NumFrames;
  int FrameWidth;
  int FrameHeight;
  long key;
  int style;
  LONGLONG lastTime;
  int sx, sy;
  DWORD flags;
  DWORD MaxLoops;
  DWORD LoopCounter;
  BOOL  AllowCentering;
  BOOL  UseAlpha;
  WORD  AlphaValue;

};

struct CLASS_BASECLASS_ID
{
  CString classID;
  CString baseclassID;
};

struct ARTMAP
{
  void operator =(const ARTMAP& src);
  CArray <CString, CString&> strings;
};




struct CELL
{
  int x;
  int y;
  int jsonLine;
  int eventID;
  CString backdrop;
  int zone;
  int     wallNorth;
  CString wallNorthBlockage;
  int     wallEast;
  CString wallEastBlockage;
  int     wallSouth;
  CString wallSouthBlockage;
  int     wallWest;
  CString wallWestBlockage;
};


class COIN_TYPE
{
public:
  enum { MAX_COIN_NAME=10 };
private:
  char Name[MAX_COIN_NAME+1];
};

class GEM_TYPE
{
public:
  int  value;
  int id;
  void Export(JWriter& jw);
  bool Read(JReader& jr);
};

class GEM_CONFIG
{
public:
  enum { MAX_NAME=10 };
  int minValue;
  int maxValue;
  char name[MAX_NAME+1];
  void Export(const CString& gemType, JWriter& jw);

};


class MONEY_DATA_TYPE
{
public:
  enum { MAX_COIN_TYPES=10, DEFAULT_COINS_PER_POUND=10 };
  COIN_TYPE Coins[MAX_COIN_TYPES];
  GEM_CONFIG Gems;
  GEM_CONFIG Jewelry;
  int HighestRate;
  int weight;
  itemClassType HRType;
  itemClassType DefType;
};

struct ITEM 
{
  void Export(JWriter& jw);
  bool Read(JReader& jr);
  int key;
	CString itemID; // was GLOBAL_ITEM_ID m_giID;  // exactly one int in size.
	int ready;
	int qty;
	int identified;
	int charges;
  BYTE cursed;
  // how much was paid for item (important for selling)
  // -1 means not purchased, use base item cost in database
  int paid; 
  bool m_scriptProcessed;
};

class TRANSFER_DATA //: public CObject
{
public:
  TRANSFER_DATA(void){Clear();};
  void Clear(void){destX=destY=0; execEvent=FALSE; m_facing=FaceUnchanged;};
  void Export(JWriter& jw, const char *name);
  void Read(JReader& jr, const char *exKey, const char *xKey, const char *ykey, const char *fKey);
  BOOL execEvent;
  eventFacingType m_facing;  // new facing at destination
  int destEP;    // destination entry point
  int destLevel;
  int destX;
  int destY;
};

class ITEM_LIST //: public CObject
{
public:
  void operator =(const ITEM_LIST& src);
  void Clear(void){m_items.RemoveAll();};
	CArray<ITEM, ITEM&> m_items;
  void Export(JWriter& jw, const char *key);
  void Read(JReader& jr, const char *key);
};



class MONEY_SACK
{
public:
  void Clear(void);
  void operator =(const MONEY_SACK& src);
  MONEY_SACK(void)
  {
    int i;
    for (i=0; i<MONEY_DATA_TYPE::MAX_COIN_TYPES; i++)
    {
      Coins[i] = 0;
    };
  };
  int Coins[MONEY_DATA_TYPE::MAX_COIN_TYPES];
  CArray<GEM_TYPE, GEM_TYPE&> Gems;
  CArray<GEM_TYPE, GEM_TYPE&> Jewelry;
  void Export(JWriter& jw);
  void Read(JReader& jr);
};


class MONSTER_EVENT //: public CObject
{
public:
   void operator =(const MONSTER_EVENT& src);
   void Export(JWriter& jw);
   bool Read(JReader& details);
   enum { meUseQty, meUsePercent };
   
   int UseQty; // use qty or roll dice
   int qty; // absolute number of monsters

   int qtyDiceSides;    // roll dice for number of monsters
   int qtyDiceQty;
   int qtyBonus;

   //int monster; // monster db key
   CString monsterID; // Used to be monster db key
   CString characterID;
   int m_type;    // monster or npc
   BOOL friendly; // whose side is monster on?
   int moraleAdj; // 
   MONEY_SACK money; // goodies in monster's inventory
   ITEM_LIST items;
};


class MONSTER_EVENT_DATA //: public CObject
{
public:
   void Export(JWriter& jw);
   void Read(JReader& jr);
   CArray<MONSTER_EVENT, MONSTER_EVENT&> monsters;
};





struct TEXT
{
  CString text;
  bool needReturn;
  bool highlight;
};

struct ENTRYPOINT
{
  int id;
  CString facing;
  int x;
  int y;
};

struct LEVELDATA
{
  void operator =(const LEVELDATA& levelData);
  int levelNum;
  CArray<ENTRYPOINT, ENTRYPOINT&> entryPoints;
};

struct BIG_SMALL_SPRITE_PIC
{
  CString file;
  CString name;
  CString value;
};

const BYTE DEFAULT_FORMAT_TYPE = 0;


struct WallSetSlotMemType
{
public:
  // Deleted 20121208 PRS
  //DECLARE_SERIAL( WallSetSlotMemType )
  WallSetSlotMemType() 
  { 
    Clear(); 
  }
  ~WallSetSlotMemType() { Clear(); }
  void Clear(void);
  void Export(JWriter& jw);
  BOOL used;
  BOOL doorFirst; // draw door before overlay?
  BOOL drawAV;    // include in area view?
  WORD SlotType;
  CString wallFileName; // "Brick" eg.
  CString wallFile;
  CString doorFile;
  CString overlayFile;
  CString soundFile;
  CString AVArtFile;

  DWORD wallHash;
  DWORD doorHash;
  DWORD overlayHash;
  DWORD AVArtHash;
  bool AVArtTried;
  BOOL AVZoneStyle;
  CString UnlockSpellName;
  BOOL BlendOverlay;
  int  BlendAmount;
};

struct BackgroundSlotMemType
{
public:
  BackgroundSlotMemType()
  { 
    Clear(); 
  }
  ~BackgroundSlotMemType() { Clear(); }

  void Clear();
  void Export(JWriter& jw);
  BOOL used;
  WORD SlotType;
  CString backgroundFile;
  CString backgroundFileAlt;
  CString soundFile;
  BOOL useAltBackground;  // use time to determine alt backdrop usage
  BOOL useAlphaBlend;     // use alpha-blend on alt backdrop
  BOOL useTransparency;   
  BOOL suppressStepSound;
  long backgroundSurface;
  long backgroundSurfaceAlt;
  DWORD backgroundFileHash;
  DWORD backgroundFileAltHash;

  long hsound;
  int StartTime;
  int EndTime;
  int AlphaBlendPcnt;
  RECT surfRect; // used for overland only
};

class BACKGROUND_SOUNDS //: public CObject
{
public:
  void Export(JWriter& jw, const char *name);
  bool Read(JReader& jr, const char *name);
  CList<CString, CString&> sounds;
};




class BACKGROUND_SOUND_DATA //: public CObject
{
public:
  void Export(JWriter& jw);
  void Read(JReader& jr);
  BACKGROUND_SOUNDS backgroundSounds;
  BACKGROUND_SOUNDS nightSounds;
  int EndTime;  // defines night-time hours
  int StartTime;
  BOOL UseNightMusic; // use nightSounds queue?
};


class ENCOUNTER_BUTTON_OPTION //: public CObject
{
public:
   void Export(JWriter& jw);
   void Import(JReader& jr, int i);
   CString label;
   BOOL present;
   BOOL allowedUpClose;
   BOOL onlyUpClose;
   encounterButtonResultType optionResult;
   DWORD chain;
};



class ENCOUNTER_BUTTON_DATA //: public CObject
{
public:
   void Export(JWriter& jw);
   bool Read(JReader& jr);
   int numButtons;   
   ENCOUNTER_BUTTON_OPTION buttons[MAX_BUTTONS];
};


class TOUR_STEP //: public CObject 
{
public:
   void Export(JWriter& jw, int stepNum);
   int Read(JReader& jr, int stepNum);
   CString text;
   eventStepType step;
};


class QLIST_OPTION //: public CObject
{
public:
   void Export(JWriter& jw);
   bool Read(JReader& jr, int i);
   CString label;
   labelPostChainOptionsType postChainAction;
   BOOL present;
   DWORD chain;
};



class QLIST_DATA //: public CObject
{
public:
   void Export(JWriter& jw);
   void Read(JReader& jr);
   CString title;
   int numListButtons;
   QLIST_OPTION buttons[MAX_BUTTONS];
};



class QBUTTON_OPTION //: public CObject
{
public:
   void Export(JWriter& jw);
   bool Read(JReader& jr);
   CString label;
   labelPostChainOptionsType postChainAction;
   BOOL present;
   DWORD chain;
};



class QBUTTON_DATA //: public CObject
{
public:
   void Export(JWriter& jw);
   bool Read(JReader& jr);
   int numListButtons;
   QBUTTON_OPTION buttons[MAX_BUTTONS];
};


struct CHARACTER_SPELL 
{
  void Export(JWriter& jw);
  bool Read(JReader& jr);
  int selected;  // TRUE if dude will memorize this spell again
	int memorized; // 
	CString spellID;      // SpellDbKey to retrieve data from spellData table
  int level;      // spell level, here for convenience
  int memTime;    // total time spent on memorizing this spell
  BOOL JustMemorized;

  int preVersionSpellNames_gsID;  // The old GLOBAL_SPELL_ID

};


struct SPELL_LIST 
{
  void Clear(void);
  CArray <CHARACTER_SPELL, CHARACTER_SPELL&> spells;
  void Export(JWriter& jw);
  bool Read(JReader& jr);
};


struct spellLimitsType
{
  void Clear(void);
  BOOL UseLimits; // some NPC types get unlimited spells
  void Export(JWriter& jw);
  bool Read(JReader& jr);
};

class SPECIAL_OBJECT_EVENT_DATA //: public CObject
{
public:
   void Export(JWriter& jw);
   int Read(JReader& jr);
   BYTE ItemType;
   BYTE operation;
   int index;
   int id;
};




class SPECIAL_OBJECT_EVENT_LIST //: public CObject
{
public:
   void Export(JWriter& jw);
   bool Read(JReader& jr);
   CArray<SPECIAL_OBJECT_EVENT_DATA, SPECIAL_OBJECT_EVENT_DATA&> list;
};




struct spellBookType
{
public:
	SPELL_LIST list;
  spellLimitsType spellLimits;
  DWORD spellPrepTimeNeeded;
  DWORD spellPrepTimeUsed;
  void Export(JWriter& jw);
  bool Read(JReader& jr);
  void Clear(void);
  void Add(const char *spellName, int level)
  {
    CHARACTER_SPELL spell;
    spell.spellID = spellName;
    spell.level = level;
    spell.memorized = 0;
    spell.selected = 0;
    list.spells.Add(spell);
  };
};







void ConvertMonsters(JReader& monsters);
void ConvertLevels(JReader& global, JReader& levels);
void ConvertItems(JReader& items);
void ConvertSpells(JReader& spells);
void ConvertGlobals(JReader& global);




void Event_General(JReader& jr, JReader& details, JWriter& jw, const char *eventType);


void Event_TextStatement  (JReader& event, JReader& details, JWriter& jw);
void Event_GuidedTour     (JReader& event, JReader& details, JWriter& jw);
void Event_QuestionList   (JReader& event, JReader& details, JWriter& jw);
void Event_Utilities      (JReader& event, JReader& details, JWriter& jw);
void Event_Chain          (JReader& event, JReader& details, JWriter& jw);
void Event_QuestionButton (JReader& event, JReader& details, JWriter& jw);
void Event_Shop           (JReader& event, JReader& details, JWriter& jw);
void Event_Camp           (JReader& event, JReader& details, JWriter& jw);
void Event_Combat         (JReader& event, JReader& details, JWriter& jw, bool pickOneCombat);
void Event_Teleporter     (JReader& event, JReader& details, JWriter& jw);
void Event_TransferModule (JReader& event, JReader& details, JWriter& jw);
void Event_Stairs         (JReader& event, JReader& details, JWriter& jw);
void Event_Null           (JReader& event, JReader& details, JWriter& jw);
void Event_Monster        (JReader& event, JReader& details, JWriter& jw);
void Event_Tour           (JReader& event, JReader& details, JWriter& jw);
void Event_AddNPC         (JReader& event, JReader& details, JWriter& jw);
void Event_RemoveNPC      (JReader& event, JReader& details, JWriter& jw);
void Event_QuestionYesNo  (JReader& event, JReader& details, JWriter& jw);
void Event_Encounter      (JReader& event, JReader& details, JWriter& jw);
void Event_Password       (JReader& event, JReader& details, JWriter& jw);
void Event_GainExperience (JReader& event, JReader& details, JWriter& jw);
void Event_GiveTreasure   (JReader& event, JReader& details, JWriter& jw);
void Event_CombatTreasure (JReader& event, JReader& details, JWriter& jw);
void Event_GiveDamage     (JReader& event, JReader& details, JWriter& jw);
void Event_Rest           (JReader& event, JReader& details, JWriter& jw);
void Event_Quest          (JReader& event, JReader& details, JWriter& jw);
void Event_NPCSays        (JReader& event, JReader& details, JWriter& jw);
void Event_TakePartyItems (JReader& event, JReader& details, JWriter& jw);
void Event_WhoPays        (JReader& event, JReader& details, JWriter& jw);
void Event_WhoTries       (JReader& event, JReader& details, JWriter& jw);
void Event_PassTime       (JReader& event, JReader& details, JWriter& jw);
void Event_Vault          (JReader& event, JReader& details, JWriter& jw);
void Event_Tavern         (JReader& event, JReader& details, JWriter& jw);
void Event_TavernTales    (JReader& event, JReader& details, JWriter& jw);
void Event_Temple         (JReader& event, JReader& details, JWriter& jw);
void Event_Random         (JReader& event, JReader& details, JWriter& jw);
void Event_SmallTown      (JReader& event, JReader& details, JWriter& jw);
void Event_TrainingHall   (JReader& event, JReader& details, JWriter& jw);
void Event_Sound          (JReader& event, JReader& details, JWriter& jw);
void Event_HealParty      (JReader& event, JReader& details, JWriter& jw);
void Event_SpecialItems   (JReader& event, JReader& details, JWriter& jw);
void Event_Journal        (JReader& event, JReader& details, JWriter& jw);


void MapGrid(JReader& mapGrid, 
             CString *wallNames, 
             CString *backdropNames, 
             int width, 
             int height);
void StepEvents (JReader& stepEvents, JWriter& jw);

struct DEFAULT_ITEM_DATA
{
  CArray<CString, CString&> key;
  CArray<CString, CString&> value;
  void Add(const char *newKey, int newValue)
  {
    CString temp;
    temp.Format("%d", newValue);
    Add(newKey, temp);
  };
  void Add(const char *newKey, const CString& newValue)
  {
    int n = key.GetSize();
    key.SetSize(n+1); value.SetSize(n+1);
    key[n] = newKey; value[n] = newValue;
  };
  void operator =(const DEFAULT_ITEM_DATA &src)
  {
    key.RemoveAll(); value.RemoveAll();
    key.Append(src.key); value.Append(src.value);
  };
};

struct LINE_ENTRY
{
  CString key;
  CString value;
};

struct LINE_DATA
{
  CArray<LINE_ENTRY, LINE_ENTRY&> lineData;
  void Add(const CString& key, const CString& value);
  void Add(const CString& key, int value);
  LINE_ENTRY *operator[](const char *key);
  LINE_ENTRY *operator[](int i);
  inline int GetSize(void){return lineData.GetSize();};
};

struct LINE_DATABASE
{
  CArray<LINE_DATA, LINE_DATA&> database;
  LINE_DATA *Add(const LINE_DATA& lineData);
  inline int GetSize(void){return database.GetSize();};
  LINE_DATA *operator[](int i);
  LINE_DATA *Find(const char *key, const char *value);
};


extern LINE_DATABASE defaultItemData;
extern LINE_DATABASE jsonItemData;


extern CArray<CString, CString&> artArray;    // From "root"/"art"
extern CArray<CString, CString&> soundArray;  // From "root"/"sounds"
